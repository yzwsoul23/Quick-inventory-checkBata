<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数据列表管理</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #f4f4f4;
        }

        #dataList {
            width: 95%;
            max-width: 800px;
            margin: 5px auto;
            padding: 10px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            height: calc(100vh - 200px);
            overflow-y: auto;
            will-change: transform; /* 提示浏览器元素会频繁变化 */
            -webkit-overflow-scrolling: touch; /* 提高移动端滚动性能 */
        }

        /* 添加加载指示器样式 */
        .loading-indicator {
            text-align: center;
            padding: 20px;
            color: #007bff;
            font-weight: bold;
        }

        /* 添加分页控制样式 */
        .pagination-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #f8f9fa;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        
        .pagination-buttons {
            display: flex;
            gap: 10px;
        }
        
        .pagination-buttons button {
            padding: 5px 15px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .pagination-buttons button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .pagination-buttons button:hover:not(:disabled) {
            background-color: #0056b3;
        }
        
        .paginated-items {
            margin-top: 10px;
        }

        .list-item {
            padding: 8px;
            border-bottom: 1.5px solid #f0f0f0;
            display: flex;
            align-items: center;
            font-size: 14px;
            flex-wrap: nowrap;
            justify-content: space-between;
            gap: 8px;
            transition: transform 0.3s, background-color 0.3s;
            touch-action: pan-y;
            user-select: none;
            cursor: default;
            will-change: transform; /* 提示浏览器元素会频繁变化 */
            contain: layout; /* 告诉浏览器此元素布局独立 */
        }

        .list-item:nth-child(even) {
            background-color: #f8f9fa;
        }

        .list-item:nth-child(odd) {
            background-color: white;
        }

        .list-item.location-item {
            background-color: #fff3cd;
            color: #dc3545;
            font-weight: bold;
        }

        .list-item:last-child {
            border-bottom: none;
        }

        .list-item:hover {
            background-color: #f0f0f0;
        }

        .input-container {
            width: 95%;
            max-width: 800px;
            margin: 5px auto;
            padding: 10px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #itemInput {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #007bff;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        #suggestions {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: none;
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            width: max-content;
            min-width: 200px;
            max-width: 100%;
        }

        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
        }

        .suggestion-item:hover {
            background-color: #f0f0f0;
        }

        .button-container {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }

        .action-btn {
            margin-left: 0;
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 12px;
            color: white;
            white-space: nowrap;
        }

        .edit-btn {
            background-color: #28a745;
        }

        .edit-btn:hover {
            background-color: #218838;
        }

        .delete-btn {
            background-color: #dc3545;
        }

        .delete-btn:hover {
            background-color: #c82333;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        #exportButton, #batchAddButton, #batchEditButton, #deleteAllButton {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            color: white;
            font-size: 14px;
            transition: background-color 0.3s;
            flex: 1 1 calc(50% - 4px);
            min-width: calc(50% - 4px);
            margin: 0;
        }

        #editModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 400px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        #editModal input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #007bff;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        #editModal button {
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        #editModal button:hover {
            background-color: #0056b3;
        }

        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 999;
        }
        #editAllModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        #editAllModal textarea {
            width: 100%;
            height: 400px;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #007bff;
            border-radius: 4px;
            margin-bottom: 10px;
            resize: vertical;
        }

        #editAllModal button {
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        #importModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        #importModal textarea {
            width: 100%;
            height: 400px;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #007bff;
            border-radius: 4px;
            margin-bottom: 10px;
            resize: vertical;
        }

        #importModal button {
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        #exportButton {
            background-color: #007bff;
        }

        #collapseAllButton {
            position: fixed;
            right: 20px;
            bottom: 70px;
            width: 40px;
            height: 40px;
            background-color: rgba(108, 117, 125, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            z-index: 999;
        }

        #collapseAllButton:hover {
            background-color: rgba(108, 117, 125, 1);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        #batchAddButton {
            background-color: #28a745;
        }

        #batchEditButton {
            background-color: #17a2b8;
        }

        #deleteAllButton {
            background-color: #dc3545;
        }

        #importModal button:hover {
            background-color: #0056b3;
        }

        #guideModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        #guideModal .guide-content {
            white-space: pre-line;
            line-height: 1.8;
            margin-bottom: 20px;
        }

        #guideModal button {
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        #guideModal button:hover {
            background-color: #0056b3;
        }

        .item-text {
            flex: 1;
            min-width: 0;
            word-break: break-all;
        }

        /* 添加折叠/展开图标的样式 */
        .collapse-icon {
            display: inline-block;
            margin-right: 0px;
            cursor: pointer;
            user-select: none;
            transition: transform 0.3s;
        }

        /* 地点行的鼠标样式 */
        .location-item {
            cursor: pointer;
        }

        /* 地点行hover效果 */
        .location-item:hover {
            background-color: #fff3cd;
        }

        /* 资产行的样式 */
        .asset-item {
            transition: all 0.3s ease;
        }

        /* 按钮不继承父元素的cursor */
        .action-btn {
            cursor: pointer;
        }

        .button-container {
            cursor: default;
        }

        #searchModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        #searchInput {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #007bff;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        #searchResults {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .search-result-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            font-size: 14px;
        }

        .search-result-location {
            color: #dc3545;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .search-result-asset {
            color: #28a745;
            margin-left: 20px;
        }

        .search-count {
            color: #007bff;
            font-weight: bold;
            margin-bottom: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }

        #searchButton {
            position: fixed;
            right: 20px;
            bottom: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(212, 168, 90, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            z-index: 999;
        }

        #closeSearchButton {
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        #closeSearchButton:hover {
            background-color: #0056b3;
        }

        /* 添加滑动提示样式 */
        .list-item.swipe-right {
            background-color: rgba(220, 53, 69, 0.2) !important; /* 右滑删除 - 红色 */
        }

        .list-item.swipe-left {
            background-color: rgba(40, 167, 69, 0.2) !important; /* 左滑编辑 - 绿色 */
        }

        /* 添加资产编号的样式 */
        .asset-number {
            display: inline-block;
            min-width: 24px;
            color: #6c757d;
            font-weight: bold;
        }

        /* 地点编辑按钮样式 */
        .location-edit-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 18px;
            padding: 2px 8px;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .location-edit-btn:hover {
            opacity: 1;
        }

        /* 地点批量编辑模态框样式 */
        #locationEditModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        #locationEditModal h3 {
            margin-bottom: 10px;
            color: #007bff;
            text-align: center;
        }

        #locationEditInput {
            width: 100%;
            height: 400px;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #007bff;
            border-radius: 4px;
            margin-bottom: 10px;
            resize: vertical;
        }

        #saveLocationEditButton {
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        #saveLocationEditButton:hover {
            background-color: #0056b3;
        }

        /* 添加回到底部按钮样式 */
        #scrollBottomButton {
            position: fixed;
            left: 20px;
            bottom: 70px;
            width: 40px;
            height: 40px;
            background-color: rgba(40, 167, 69, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            z-index: 999;
        }
        
        #scrollBottomButton:hover {
            background-color: rgba(40, 167, 69, 1);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        /* 添加备份模态框样式 */
        #backupModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        
        #backupModal h3, #backupModal h4 {
            margin-bottom: 10px;
            color: #007bff;
            text-align: center;
        }
        
        .backup-info {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        
        .backup-info p {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .backup-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .backup-buttons button {
            flex: 1;
            min-width: calc(50% - 5px);
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            color: white;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        #manualBackupButton {
            background-color: #28a745;
        }
        
        #manualBackupButton:hover {
            background-color: #218838;
        }
        
        #restoreBackupButton {
            background-color: #17a2b8;
        }
        
        #restoreBackupButton:hover {
            background-color: #138496;
        }
        
        #exportBackupButton {
            background-color: #007bff;
        }
        
        #exportBackupButton:hover {
            background-color: #0069d9;
        }
        
        #importBackupButton {
            background-color: #6c757d;
        }
        
        #importBackupButton:hover {
            background-color: #5a6268;
        }
        
        .backup-options {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        
        .backup-options label {
            display: block;
            margin: 8px 0;
            font-size: 14px;
        }
        
        .backup-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .backup-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #eee;
        }
        
        .backup-item:last-child {
            border-bottom: none;
        }
        
        .backup-item-info {
            flex: 2;
        }
        
        .backup-item-time {
            font-weight: bold;
            color: #007bff;
        }
        
        .backup-item-desc, .backup-item-count {
            color: #6c757d;
            font-size: 12px;
        }
        
        .backup-item-actions {
            flex: 1;
            display: flex;
            justify-content: flex-end;
            gap: 5px;
        }
        
        .backup-item-actions button {
            padding: 3px 8px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            color: white;
            cursor: pointer;
        }
        
        .backup-restore-btn {
            background-color: #17a2b8;
        }
        
        .backup-export-btn {
            background-color: #007bff;
        }
        
        .backup-delete-btn {
            background-color: #dc3545;
        }
        
        #closeBackupModalButton {
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        #closeBackupModalButton:hover {
            background-color: #0056b3;
        }
        
        .no-backup, .backup-error {
            text-align: center;
            padding: 20px;
            color: #6c757d;
            font-style: italic;
        }
        
        .backup-error {
            color: #dc3545;
        }
    </style>
</head>
<body>
    <div id="overlay"></div>
    <div id="editModal">
        <input type="text" id="editInput" placeholder="输入修改后的内容">
        <button id="saveEditButton">保存修改</button>
    </div>
    <div id="importModal">
        <textarea id="importInput" placeholder="请输入要导入的数据，每行一条"></textarea>
        <button id="savebatchAddButton">确认保存</button>
    </div>
    <div id="editAllModal">
        <textarea id="editAllInput" placeholder="请修改数据，每行一条"></textarea>
        <button id="saveEditAllButton">确认修改</button>
    </div>
    <div id="searchModal">
        <input type="text" id="searchInput" placeholder="输入要搜索的资产关键词">
        <div id="searchResults"></div>
        <button id="closeSearchButton">关闭</button>
    </div>

    <div id="dataList"></div>
    <button id="searchButton" title="搜索资产">🔍</button>
    <button id="collapseAllButton" title="折叠/展开">▼</button>
    <div class="input-container">
        <input type="text" id="itemInput" placeholder="输入内容并选择建议项...">
        <div id="suggestions"></div>
        <div class="button-group">
            <button id="exportButton">导出TXT</button>
            <button id="batchAddButton">批量添加</button>
            <button id="batchEditButton">批量修改</button>
            <button id="deleteAllButton">删除全部</button>
        </div>
    </div>
    <div id="guideModal">
        <div class="guide-content">
            快速操作指南：

            基本操作：
            - 在输入框输入内容后点击回车键或按下添加按钮可添加新数据行
            - 长按任何数据行可复制该行内容
            - 向左滑动数据行可编辑内容
            - 向右滑动数据行可删除内容（地点行会同时删除其所有资产）
            
            地点管理：
            - 以@开头的行会自动标记为地点行（黄底红字）
            - 点击地点行可展开/折叠该地点下的所有资产
            - 点击地点行右侧的✏️按钮可批量编辑该地点及其所有资产
            - 相同地点名称不允许重复添加
            - 第一个地点行"@模板资产"用于存放模板数据，不会被导出
            
            批量操作：
            - 点击"批量添加"可一次性添加多条数据（每行一条）
            - 点击"批量修改"可编辑全部数据内容
            - 点击"删除全部"可清空除模板资产外的所有数据
            - 点击"导出TXT"可将数据（除模板资产外）导出为文本文件
            
            辅助功能：
            - 右下角↑按钮可快速返回列表顶部
            - 右下角▼/▶按钮可一键折叠/展开所有地点
            - 右下角🔍按钮可搜索资产，结果按地点分组显示
            
            使用技巧：
            - 每个地点下的资产会自动编号（1. 2. 3. ...）
            - 批量导入时会自动检查地点是否重复
            - 长按复制内容可用于快速创建类似条目
            - 折叠不常用地点可使列表更简洁
            
            提示：该应用数据存储在本地浏览器中，清除浏览器数据可能导致信息丢失，建议定期导出备份。
        </div>
        <button id="closeGuideButton">我知道了</button>
    </div>

    <!-- 添加地点批量编辑模态框 -->
    <div id="locationEditModal">
        <h3>编辑地点及资产</h3>
        <textarea id="locationEditInput" placeholder="编辑地点及其所有资产，每行一条"></textarea>
        <button id="saveLocationEditButton">保存修改</button>
    </div>

    <!-- 添加备份模态框 -->
    <div id="backupModal">
        <h3>数据备份与恢复</h3>
        <div class="backup-info">
            <p>上次自动备份时间：<span id="lastBackupTime">无</span></p>
            <p>当前自动备份状态：<span id="backupStatus">已启用</span></p>
        </div>
        <div class="backup-buttons">
            <button id="manualBackupButton">立即备份</button>
            <button id="restoreBackupButton">恢复备份</button>
            <button id="exportBackupButton">导出备份文件</button>
            <button id="importBackupButton">导入备份文件</button>
            <input type="file" id="backupFileInput" accept=".json" style="display: none;">
        </div>
        <div class="backup-options">
            <label>
                <input type="checkbox" id="autoBackupEnabled" checked>
                启用自动备份
            </label>
            <label>
                备份频率：
                <select id="backupFrequency">
                    <option value="3600000">每小时</option>
                    <option value="86400000" selected>每天</option>
                    <option value="604800000">每周</option>
                </select>
            </label>
            <label>
                保留备份数：
                <select id="backupRetention">
                    <option value="1">1个</option>
                    <option value="3" selected>3个</option>
                    <option value="5">5个</option>
                    <option value="10">10个</option>
                </select>
            </label>
        </div>
        <div class="backup-list">
            <h4>可用备份列表</h4>
            <div id="backupsList"></div>
        </div>
        <button id="closeBackupModalButton">关闭</button>
    </div>

    <script>
        let items = [];
        let currentEditIndex = null;
        let db;
        let isAllCollapsed = false;
        let saveItemTimeout = null; // 添加 saveItemTimeout 变量声明
        
        const dataList = document.getElementById('dataList');
        const itemInput = document.getElementById('itemInput');
        const suggestions = document.getElementById('suggestions');
        const exportButton = document.getElementById('exportButton');
        const batchEditButton = document.getElementById('batchEditButton');
        const editModal = document.getElementById('editModal');
        const editInput = document.getElementById('editInput');
        const saveEditButton = document.getElementById('saveEditButton');
        const overlay = document.getElementById('overlay');
        const editAllModal = document.getElementById('editAllModal');
        const importModal = document.getElementById('importModal');
        const importInput = document.getElementById('importInput');
        const batchAddButton = document.getElementById('batchAddButton');
        const savebatchAddButton = document.getElementById('savebatchAddButton');
        const deleteAllButton = document.getElementById('deleteAllButton');
        const guideModal = document.getElementById('guideModal');
        const closeGuideButton = document.getElementById('closeGuideButton');
        const collapseAllButton = document.getElementById('collapseAllButton');
        const searchButton = document.getElementById('searchButton');
        const searchModal = document.getElementById('searchModal');
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const closeSearchButton = document.getElementById('closeSearchButton');
        const locationEditModal = document.getElementById('locationEditModal');
        const locationEditInput = document.getElementById('locationEditInput');
        const saveLocationEditButton = document.getElementById('saveLocationEditButton');
        let currentLocationEditIndex = -1;

        // 添加备份相关变量
        let backupSettings = {
            enabled: true,
            frequency: 86400000, // 默认每天备份一次（毫秒）
            retention: 3,        // 默认保留3个备份
            lastBackupTime: null // 上次备份时间
        };
        let backupTimer = null;
        let backups = [];       // 备份列表
        
        // 添加备份相关DOM引用
        const backupModal = document.getElementById('backupModal');
        const lastBackupTimeSpan = document.getElementById('lastBackupTime');
        const backupStatusSpan = document.getElementById('backupStatus');
        const manualBackupButton = document.getElementById('manualBackupButton');
        const restoreBackupButton = document.getElementById('restoreBackupButton');
        const exportBackupButton = document.getElementById('exportBackupButton');
        const importBackupButton = document.getElementById('importBackupButton');
        const backupFileInput = document.getElementById('backupFileInput');
        const autoBackupEnabledCheckbox = document.getElementById('autoBackupEnabled');
        const backupFrequencySelect = document.getElementById('backupFrequency');
        const backupRetentionSelect = document.getElementById('backupRetention');
        const backupsList = document.getElementById('backupsList');
        const closeBackupModalButton = document.getElementById('closeBackupModalButton');
        
        // 使用事件委托添加交互事件，修复之前可能的问题
        function setupEventDelegation() {
            try {
                // 移除可能存在的事件监听器
                dataList.removeEventListener('click', handleListClick);
                dataList.removeEventListener('mousedown', handleListMouseDown);
                dataList.removeEventListener('mousemove', handleListMouseMove);
                dataList.removeEventListener('mouseup', handleListMouseUp);
                dataList.removeEventListener('mouseleave', handleListMouseLeave);
                dataList.removeEventListener('touchstart', handleListTouchStart);
                dataList.removeEventListener('touchmove', handleListTouchMove);
                dataList.removeEventListener('touchend', handleListTouchEnd);
                dataList.removeEventListener('touchcancel', handleListTouchCancel);
                dataList.removeEventListener('dblclick', handleListDblClick);
                
                // 添加委托事件处理
                dataList.addEventListener('click', handleListClick);
                dataList.addEventListener('mousedown', handleListMouseDown);
                dataList.addEventListener('mousemove', handleListMouseMove);
                dataList.addEventListener('mouseup', handleListMouseUp);
                dataList.addEventListener('mouseleave', handleListMouseLeave);
                dataList.addEventListener('touchstart', handleListTouchStart);
                dataList.addEventListener('touchmove', handleListTouchMove);
                dataList.addEventListener('touchend', handleListTouchEnd);
                dataList.addEventListener('touchcancel', handleListTouchCancel);
                dataList.addEventListener('dblclick', handleListDblClick);
                
                console.log('事件委托设置完成');
            } catch (error) {
                console.error('设置事件委托时出错:', error);
                
                // 降级处理：确保基本的折叠/展开功能可用
                try {
                    const locationItems = document.querySelectorAll('.location-item');
                    locationItems.forEach(item => {
                        item.addEventListener('click', function(e) {
                            if (!e.target.closest('.location-edit-btn')) {
                                const locationIndex = parseInt(this.getAttribute('data-location-index'));
                                const assets = document.querySelectorAll(`[data-belongs-to="${locationIndex}"]`);
                                const collapseIcon = this.querySelector('.collapse-icon');
                                
                                const isCollapsed = assets.length > 0 && assets[0].style.display === 'none';
                                
                                assets.forEach(asset => {
                                    asset.style.display = isCollapsed ? 'flex' : 'none';
                                });
                                
                                collapseIcon.textContent = isCollapsed ? '▼' : '▶';
                            }
                        });
                    });
                    
                    const editButtons = document.querySelectorAll('.location-edit-btn');
                    editButtons.forEach(button => {
                        button.addEventListener('click', function(e) {
                            e.stopPropagation();
                            const locationIndex = parseInt(this.getAttribute('data-location'));
                            openLocationEditor(locationIndex);
                        });
                    });
                    
                    console.log('降级事件绑定设置完成');
                } catch (fallbackError) {
                    console.error('降级事件绑定失败:', fallbackError);
                }
            }
        }

        // 修改保存数据到IndexedDB的函数，简化防抖逻辑
        const saveItem = (value) => {
            try {
                const transaction = db.transaction(['items'], 'readwrite');
                const store = transaction.objectStore('items');
                
                const request = store.add({ value });
                
                request.onerror = (event) => {
                    console.error('保存数据错误：', event.target.error);
                };
                
                transaction.oncomplete = () => {
                    console.log('数据保存成功，加载最新数据');
                    loadItems(); // 直接触发重新加载
                };
            } catch (error) {
                console.error('保存数据时出错:', error);
                alert('保存数据失败，请刷新页面后重试');
            }
        };

        // 确保IndexedDB初始化代码可靠
        const initDB = () => {
            try {
                const request = indexedDB.open('ItemsDB', 1);
                
                request.onerror = (event) => {
                    console.error('数据库错误：', event.target.error);
                    alert('无法打开数据库，请检查浏览器设置或刷新页面');
                };

                request.onupgradeneeded = (event) => {
                    console.log('数据库升级中...');
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('items')) {
                        db.createObjectStore('items', { keyPath: 'id', autoIncrement: true });
                        console.log('创建items存储对象成功');
                    }
                };

                request.onsuccess = (event) => {
                    console.log('数据库打开成功');
                    db = event.target.result;
                    
                    // 确保数据库连接有效
                    db.onversionchange = () => {
                        db.close();
                        alert('数据库已过时，请刷新页面');
                    };
                    
                    // 立即加载数据
                    loadItems();
                    
                    // 初始化备份系统
                    setupBackup();
                };
            } catch (error) {
                console.error('初始化数据库时出错:', error);
                alert('初始化数据库失败，请刷新页面后重试');
            }
        };

        // 修改从IndexedDB加载数据的函数
        const loadItems = () => {
            const transaction = db.transaction(['items'], 'readonly');
            const store = transaction.objectStore('items');
            const request = store.getAll();

            request.onerror = (event) => {
                console.error('加载数据错误：', event.target.error);
            };

            request.onsuccess = () => {
                // 直接加载数据并渲染，不使用延迟
                items = request.result.map(item => item.value);
                console.log(`数据加载成功，共 ${items.length} 条记录`);
                refreshList();
                
                // 检查是否需要显示指南
                if (items.length === 0) {
                    guideModal.style.display = 'block';
                    overlay.style.display = 'block';
                }
            };
        };

        // 更新IndexedDB中的数据
        const updateItem = (index, newValue) => {
            try {
                const transaction = db.transaction(['items'], 'readwrite');
                const store = transaction.objectStore('items');
                
                // 先获取要更新的记录
                const cursorRequest = store.openCursor();
                let count = 0;
                
                cursorRequest.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        if (count === index) {
                            cursor.update({ id: cursor.key, value: newValue });
                        }
                        count++;
                        cursor.continue();
                    }
                };

                transaction.oncomplete = () => {
                    console.log('更新数据成功，重新加载数据');
                    loadItems(); // 直接加载数据
                };
            } catch (error) {
                console.error('更新数据时出错:', error);
                alert('更新数据失败，请刷新页面后重试');
            }
        };

        // 优化删除数据的函数
        const deleteItem = (index) => {
            try {
                const transaction = db.transaction(['items'], 'readwrite');
                const store = transaction.objectStore('items');
                
                const cursorRequest = store.openCursor();
                let count = 0;
                
                cursorRequest.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        if (count === index) {
                            cursor.delete();
                        }
                        count++;
                        cursor.continue();
                    }
                };

                transaction.oncomplete = () => {
                    console.log('删除数据成功，重新加载数据');
                    loadItems(); // 直接加载数据
                };
            } catch (error) {
                console.error('删除数据时出错:', error);
                alert('删除数据失败，请刷新页面后重试');
            }
        };

        // 优化删除地点及其资产的函数
        function deleteLocationAndAssets(locationIndex) {
            // 确保该索引存在且是地点行
            if (!items[locationIndex] || !items[locationIndex].startsWith('@')) {
                return;
            }
            
            // 第一个地点行（模板资产）不允许删除
            if (locationIndex === 0) {
                showErrorToast('模板地点不能删除');
                return;
            }
            
            // 找出所有属于该地点的资产范围
            let nextLocationIndex = locationIndex + 1;
            while (nextLocationIndex < items.length && !items[nextLocationIndex].startsWith('@')) {
                nextLocationIndex++;
            }
            
            // 计算要删除的项目数
            const deleteCount = nextLocationIndex - locationIndex;
            
            // 显示删除中提示
            showToast('正在删除中...');
            
            // 使用事务同步处理数据
            const transaction = db.transaction(['items'], 'readwrite');
            const store = transaction.objectStore('items');
            
            // 先获取所有数据
            const getAllRequest = store.getAll();
            
            getAllRequest.onsuccess = () => {
                const allItems = getAllRequest.result;
                
                // 清除store后重新添加数据，跳过要删除的部分
                store.clear().onsuccess = () => {
                    // 同步添加删除前的数据
                    for (let i = 0; i < locationIndex; i++) {
                        store.add(allItems[i]);
                    }
                    
                    // 同步添加删除后的数据
                    for (let i = locationIndex + deleteCount; i < allItems.length; i++) {
                        store.add(allItems[i]);
                    }
                    
                    transaction.oncomplete = () => {
                        loadItems();
                        showToast(`已删除"${items[locationIndex]}"及其所有资产`);
                    };
                };
            };
        }

        // 修改 refreshList 函数，简化处理逻辑
        function refreshList() {
            console.log('刷新列表中，数据条数:', items.length);
            
            // 暂时禁用高级功能，确保基本显示正常
            const useSimpleMode = true;
            
            if (useSimpleMode || items.length < 500) {
                // 使用简单模式渲染，确保可以显示
                renderSimpleList();
            } else {
                // 使用分批模式渲染
                if (appSettings && typeof appSettings.adjustForDataSize === 'function') {
                    appSettings.adjustForDataSize();
                    
                    if (appSettings.usePagination) {
                        renderPaginatedItems();
                    } else {
                        renderBatchedItems();
                    }
                } else {
                    renderSimpleList(); // 降级到简单渲染
                }
            }
        }

        // 添加简单渲染函数，确保基本功能可用
        function renderSimpleList() {
            // 使用DocumentFragment减少重排重绘
            const fragment = document.createDocumentFragment();
            let currentLocationIndex = -1;
            let assetCounter = 0;
            
            // 创建和填充每个列表项
            items.forEach((item, index) => {
                const listItem = document.createElement('div');
                
                if (item.startsWith('@')) {
                    currentLocationIndex = index;
                    assetCounter = 0;
                    listItem.className = 'list-item location-item';
                    listItem.setAttribute('data-location-index', index);
                    listItem.setAttribute('data-index', index);
                    
                    listItem.innerHTML = `
                        <div class="item-text">
                            <span class="collapse-icon">${index === 0 ? '▶' : '▼'}</span> ${item}
                        </div>
                        <button class="location-edit-btn" data-location="${index}" title="批量编辑此地点及资产">✏️</button>
                    `;
                } else {
                    assetCounter++;
                    listItem.className = 'list-item asset-item';
                    listItem.setAttribute('data-belongs-to', currentLocationIndex);
                    listItem.setAttribute('data-index', index);
                    
                    if (currentLocationIndex === 0) {
                        listItem.style.display = 'none';
                    }
                    
                    listItem.innerHTML = `
                        <div class="item-text"><span class="asset-number">${assetCounter}. </span>${item}</div>
                    `;
                }
                
                fragment.appendChild(listItem);
            });
            
            // 清空容器并一次性添加所有元素
            dataList.innerHTML = '';
            dataList.appendChild(fragment);
            
            // 使用事件委托添加事件处理
            setupEventDelegation();
        }
        
        // 添加分页渲染函数
        function renderPaginatedItems() {
            const totalItems = items.length;
            const totalPages = Math.ceil(totalItems / appSettings.pageSize);
            
            // 确保当前页在有效范围内
            if (appSettings.currentPage < 1) appSettings.currentPage = 1;
            if (appSettings.currentPage > totalPages) appSettings.currentPage = totalPages;
            
            // 计算当前页的起始和结束索引
            const startIdx = (appSettings.currentPage - 1) * appSettings.pageSize;
            const endIdx = Math.min(startIdx + appSettings.pageSize, totalItems);
            
            // 显示加载提示和分页控制
            dataList.innerHTML = `
                <div class="pagination-controls">
                    <span>总共 ${totalItems} 项，第 ${appSettings.currentPage}/${totalPages} 页</span>
                    <div class="pagination-buttons">
                        <button id="prevPage" ${appSettings.currentPage === 1 ? 'disabled' : ''}>上一页</button>
                        <button id="nextPage" ${appSettings.currentPage === totalPages ? 'disabled' : ''}>下一页</button>
                    </div>
                </div>
                <div class="loading-indicator">数据加载中，请稍候...</div>
            `;
            
            // 获取分页按钮引用
            const prevPageBtn = document.getElementById('prevPage');
            const nextPageBtn = document.getElementById('nextPage');
            
            // 添加事件监听器
            prevPageBtn.addEventListener('click', () => {
                if (appSettings.currentPage > 1) {
                    appSettings.currentPage--;
                    refreshList();
                }
            });
            
            nextPageBtn.addEventListener('click', () => {
                if (appSettings.currentPage < totalPages) {
                    appSettings.currentPage++;
                    refreshList();
                }
            });
            
            // 使用setTimeout避免阻塞UI
            setTimeout(() => {
                const fragment = document.createDocumentFragment();
                let currentLocationIndex = -1;
                let assetCounter = 0;
                
                // 查找最近的地点行索引
                for (let i = startIdx - 1; i >= 0; i--) {
                    if (items[i].startsWith('@')) {
                        currentLocationIndex = i;
                        
                        // 计算此地点下已有多少资产
                        for (let j = i + 1; j < startIdx; j++) {
                            if (!items[j].startsWith('@')) {
                                assetCounter++;
                            } else {
                                break;
                            }
                        }
                        break;
                    }
                }
                
                // 删除加载提示但保留分页控制
                const loadingIndicator = document.querySelector('.loading-indicator');
                if (loadingIndicator) {
                    loadingIndicator.remove();
                }
                
                // 创建数据容器
                const itemsContainer = document.createElement('div');
                itemsContainer.className = 'paginated-items';
                
                // 渲染当前页的数据项
                for (let i = startIdx; i < endIdx; i++) {
                    const item = items[i];
                    const listItem = document.createElement('div');
                    
                    if (item.startsWith('@')) {
                        currentLocationIndex = i;
                        assetCounter = 0;
                        listItem.className = 'list-item location-item';
                        listItem.setAttribute('data-location-index', i);
                        listItem.setAttribute('data-index', i);
                        
                        listItem.innerHTML = `
                            <div class="item-text">
                                <span class="collapse-icon">${i === 0 ? '▶' : '▼'}</span> ${item}
                            </div>
                            <button class="location-edit-btn" data-location="${i}" title="批量编辑此地点及资产">✏️</button>
                        `;
                    } else {
                        assetCounter++;
                        listItem.className = 'list-item asset-item';
                        listItem.setAttribute('data-belongs-to', currentLocationIndex);
                        listItem.setAttribute('data-index', i);
                        
                        if (currentLocationIndex === 0) {
                            listItem.style.display = 'none';
                        }
                        
                        listItem.innerHTML = `
                            <div class="item-text"><span class="asset-number">${assetCounter}. </span>${item}</div>
                        `;
                    }
                    
                    itemsContainer.appendChild(listItem);
                }
                
                fragment.appendChild(itemsContainer);
                dataList.appendChild(fragment);
                
                // 使用事件委托添加事件处理
                setupEventDelegation();
            }, 10);
        }
        
        // 添加分批渲染函数，用于处理大量数据
        function renderBatchedItems() {
            let batchSize = 100; // 每批渲染的项目数
            let currentBatch = 0;
            let totalBatches = Math.ceil(items.length / batchSize);
            
            // 显示加载提示
            dataList.innerHTML = '<div class="loading-indicator">数据加载中，请稍候...</div>';
            
            function renderBatch() {
                if (currentBatch >= totalBatches) {
                    // 所有批次都已渲染完成，设置事件委托
                    setupEventDelegation();
                    return;
                }
                
                const fragment = document.createDocumentFragment();
                let startIndex = currentBatch * batchSize;
                let endIndex = Math.min(startIndex + batchSize, items.length);
                let currentLocationIndex = -1;
                let assetCounter = 0;
                
                // 查找最近的地点行索引
                for (let i = startIndex - 1; i >= 0; i--) {
                    if (items[i].startsWith('@')) {
                        currentLocationIndex = i;
                        
                        // 计算此地点下已有多少资产
                        for (let j = i + 1; j < startIndex; j++) {
                            if (!items[j].startsWith('@')) {
                                assetCounter++;
                            } else {
                                break;
                            }
                        }
                        break;
                    }
                }
                
                // 删除加载提示(仅第一批)
                if (currentBatch === 0) {
                    dataList.innerHTML = '';
                }
                
                // 创建此批次的元素
                for (let i = startIndex; i < endIndex; i++) {
                    const item = items[i];
                    const listItem = document.createElement('div');
                    
                    if (item.startsWith('@')) {
                        currentLocationIndex = i;
                        assetCounter = 0;
                        listItem.className = 'list-item location-item';
                        listItem.setAttribute('data-location-index', i);
                        listItem.setAttribute('data-index', i);
                        
                        listItem.innerHTML = `
                            <div class="item-text">
                                <span class="collapse-icon">${i === 0 ? '▶' : '▼'}</span> ${item}
                            </div>
                            <button class="location-edit-btn" data-location="${i}" title="批量编辑此地点及资产">✏️</button>
                        `;
                    } else {
                        assetCounter++;
                        listItem.className = 'list-item asset-item';
                        listItem.setAttribute('data-belongs-to', currentLocationIndex);
                        listItem.setAttribute('data-index', i);
                        
                        if (currentLocationIndex === 0) {
                            listItem.style.display = 'none';
                        }
                        
                        listItem.innerHTML = `
                            <div class="item-text"><span class="asset-number">${assetCounter}. </span>${item}</div>
                        `;
                    }
                    
                    fragment.appendChild(listItem);
                }
                
                dataList.appendChild(fragment);
                
                // 安排下一批次渲染
                currentBatch++;
                setTimeout(renderBatch, 0);
            }
            
            // 开始渲染第一批
            setTimeout(renderBatch, 0);
        }
        
        // 点击事件处理
        function handleListClick(e) {
            try {
                const listItem = e.target.closest('.list-item');
                if (!listItem) return;
                
                // 地点项的点击事件（折叠/展开）
                if (listItem.classList.contains('location-item') && 
                    !e.target.classList.contains('location-edit-btn')) {
                    
                    const locationIndex = parseInt(listItem.getAttribute('data-location-index'));
                    const assets = document.querySelectorAll(`[data-belongs-to="${locationIndex}"]`);
                    const collapseIcon = listItem.querySelector('.collapse-icon');
                    
                    console.log(`点击地点行 ${locationIndex}，找到 ${assets.length} 个资产项`);
                    
                    if (assets.length === 0) return; // 没有资产项
                    
                    // 检查第一个资产是否隐藏，来判断当前状态
                    const isCollapsed = assets[0].style.display === 'none';
                    
                    // 切换资产显示状态
                    assets.forEach(asset => {
                        asset.style.display = isCollapsed ? 'flex' : 'none';
                    });
                    
                    collapseIcon.textContent = isCollapsed ? '▼' : '▶';
                }
                
                // 地点编辑按钮的点击事件
                if (e.target.classList.contains('location-edit-btn')) {
                    e.stopPropagation();
                    const locationIndex = parseInt(e.target.getAttribute('data-location'));
                    openLocationEditor(locationIndex);
                }
            } catch (error) {
                console.error('点击事件处理出错:', error);
            }
        }
        
        // 双击事件处理 - 复制功能
        function handleListDblClick(e) {
            const listItem = e.target.closest('.list-item');
            if (!listItem) return;
            
            // 如果点击的是按钮或折叠图标，不触发复制
            if (e.target.classList.contains('action-btn') || 
                e.target.classList.contains('collapse-icon') ||
                e.target.classList.contains('location-edit-btn')) {
                return;
            }
            
            const text = listItem.querySelector('.item-text').textContent.trim();
            copyToClipboard(text);
            showToast('已复制到剪贴板！');
        }
        
        // 触摸/鼠标事件相关变量
        let touchStartX = 0;
        let touchCurrentX = 0;
        let isSwiping = false;
        let activeItem = null;
        
        // 鼠标按下事件
        function handleListMouseDown(e) {
            const listItem = e.target.closest('.list-item');
            if (!listItem) return;
            
            // 如果点击的是按钮或折叠图标，不触发滑动
            if (e.target.classList.contains('action-btn') || 
                e.target.classList.contains('collapse-icon') ||
                e.target.classList.contains('location-edit-btn')) {
                return;
            }
            
            touchStartX = e.clientX;
            touchCurrentX = e.clientX;
            isSwiping = true;
            activeItem = listItem;
        }
        
        // 鼠标移动事件
        function handleListMouseMove(e) {
            if (!isSwiping || !activeItem) return;
            
            touchCurrentX = e.clientX;
            const diffX = touchCurrentX - touchStartX;
            
            // 应用滑动效果
            if (Math.abs(diffX) < 100) { // 限制滑动距离
                activeItem.style.transform = `translateX(${diffX}px)`;
                
                // 改变背景色以提示操作
                if (diffX > 30) { // 右滑 - 删除
                    activeItem.style.backgroundColor = 'rgba(220, 53, 69, 0.2)'; // 淡红色
                } else if (diffX < -30) { // 左滑 - 编辑
                    activeItem.style.backgroundColor = 'rgba(40, 167, 69, 0.2)'; // 淡绿色
                } else {
                    activeItem.style.backgroundColor = '';
                }
            }
        }
        
        // 鼠标抬起事件
        function handleListMouseUp(e) {
            if (!isSwiping || !activeItem) return;
            
            const diffX = touchCurrentX - touchStartX;
            const itemIndex = parseInt(activeItem.getAttribute('data-index'));
            
            // 重置样式
            activeItem.style.transition = 'transform 0.3s, background-color 0.3s';
            activeItem.style.transform = 'translateX(0)';
            activeItem.style.backgroundColor = '';
            
            // 执行相应操作
            if (Math.abs(diffX) > 50) { // 需要滑动50px以上才触发操作
                if (diffX > 50) { // 右滑 - 删除
                    // 判断是否为地点行
                    if (activeItem.classList.contains('location-item')) {
                        if (confirm('确定要删除此地点及其所有资产吗？此操作不可恢复！')) {
                            deleteLocationAndAssets(itemIndex);
                        }
                    } else {
                        // 普通资产行删除
                        if (confirm('确定要删除这条记录吗？')) {
                            deleteItem(itemIndex);
                        }
                    }
                } else if (diffX < -50) { // 左滑 - 编辑
                    currentEditIndex = itemIndex;
                    editInput.value = items[itemIndex];
                    editModal.style.display = 'block';
                    overlay.style.display = 'block';
                    
                    // 添加这段代码，将光标放在文本末尾
                    setTimeout(() => {
                        editInput.focus();
                        editInput.selectionStart = editInput.value.length;
                        editInput.selectionEnd = editInput.value.length;
                    }, 50);
                }
            }
            
            // 300ms后移除过渡效果
            setTimeout(() => {
                if (activeItem) {
                    activeItem.style.transition = '';
                }
            }, 300);
            
            isSwiping = false;
            activeItem = null;
        }
        
        // 鼠标离开事件
        function handleListMouseLeave(e) {
            if (!isSwiping || !activeItem) return;
            
            // 重置样式
            activeItem.style.transition = 'transform 0.3s, background-color 0.3s';
            activeItem.style.transform = 'translateX(0)';
            activeItem.style.backgroundColor = '';
            
            setTimeout(() => {
                if (activeItem) {
                    activeItem.style.transition = '';
                }
            }, 300);
            
            isSwiping = false;
            activeItem = null;
        }
        
        // 触摸开始事件
        function handleListTouchStart(e) {
            const listItem = e.target.closest('.list-item');
            if (!listItem) return;
            
            // 如果触摸的是按钮或折叠图标，不触发滑动
            if (e.target.classList.contains('action-btn') || 
                e.target.classList.contains('collapse-icon') ||
                e.target.classList.contains('location-edit-btn')) {
                return;
            }
            
            touchStartX = e.touches[0].clientX;
            touchCurrentX = e.touches[0].clientX;
            isSwiping = true;
            activeItem = listItem;
        }
        
        // 触摸移动事件
        function handleListTouchMove(e) {
            if (!isSwiping || !activeItem) return;
            
            touchCurrentX = e.touches[0].clientX;
            const diffX = touchCurrentX - touchStartX;
            
            // 应用滑动效果
            if (Math.abs(diffX) < 100) { // 限制滑动距离
                activeItem.style.transform = `translateX(${diffX}px)`;
                
                // 改变背景色以提示操作
                if (diffX > 30) { // 右滑 - 删除
                    activeItem.style.backgroundColor = 'rgba(220, 53, 69, 0.2)'; // 淡红色
                } else if (diffX < -30) { // 左滑 - 编辑
                    activeItem.style.backgroundColor = 'rgba(40, 167, 69, 0.2)'; // 淡绿色
                } else {
                    activeItem.style.backgroundColor = '';
                }
            }
        }
        
        // 触摸结束事件
        function handleListTouchEnd(e) {
            if (!isSwiping || !activeItem) return;
            
            const diffX = touchCurrentX - touchStartX;
            const itemIndex = parseInt(activeItem.getAttribute('data-index'));
            
            // 重置样式
            activeItem.style.transition = 'transform 0.3s, background-color 0.3s';
            activeItem.style.transform = 'translateX(0)';
            activeItem.style.backgroundColor = '';
            
            // 执行相应操作
            if (Math.abs(diffX) > 50) { // 需要滑动50px以上才触发操作
                if (diffX > 50) { // 右滑 - 删除
                    // 判断是否为地点行
                    if (activeItem.classList.contains('location-item')) {
                        if (confirm('确定要删除此地点及其所有资产吗？此操作不可恢复！')) {
                            deleteLocationAndAssets(itemIndex);
                        }
                    } else {
                        // 普通资产行删除
                        if (confirm('确定要删除这条记录吗？')) {
                            deleteItem(itemIndex);
                        }
                    }
                } else if (diffX < -50) { // 左滑 - 编辑
                    currentEditIndex = itemIndex;
                    editInput.value = items[itemIndex];
                    editModal.style.display = 'block';
                    overlay.style.display = 'block';
                    
                    // 添加这段代码，将光标放在文本末尾
                    setTimeout(() => {
                        editInput.focus();
                        editInput.selectionStart = editInput.value.length;
                        editInput.selectionEnd = editInput.value.length;
                    }, 50);
                }
            }
            
            // 300ms后移除过渡效果
            setTimeout(() => {
                if (activeItem) {
                    activeItem.style.transition = '';
                }
            }, 300);
            
            isSwiping = false;
            activeItem = null;
        }
        
        // 触摸取消事件
        function handleListTouchCancel(e) {
            if (!isSwiping || !activeItem) return;
            
            // 重置样式
            activeItem.style.transition = 'transform 0.3s, background-color 0.3s';
            activeItem.style.transform = 'translateX(0)';
            activeItem.style.backgroundColor = '';
            
            setTimeout(() => {
                if (activeItem) {
                    activeItem.style.transition = '';
                }
            }, 300);
            
            isSwiping = false;
            activeItem = null;
        }

        // 打开地点批量编辑器
        function openLocationEditor(locationIndex) {
            // 确保该索引存在且是地点行
            if (!items[locationIndex] || !items[locationIndex].startsWith('@')) {
                return;
            }
            
            // 收集当前地点及其所有资产
            const locationData = [items[locationIndex]];
            let nextIndex = locationIndex + 1;
            
            // 找出所有属于该地点的资产
            while (nextIndex < items.length && !items[nextIndex].startsWith('@')) {
                locationData.push(items[nextIndex]);
                nextIndex++;
            }
            
            // 填充编辑框内容
            locationEditInput.value = locationData.join('\n');
            
            // 记录当前编辑的地点索引
            currentLocationEditIndex = locationIndex;
            
            // 显示模态框
            locationEditModal.style.display = 'block';
            overlay.style.display = 'block';
            
            // 将光标放在文本框末尾，而不是选中全部文本
            setTimeout(() => {
                locationEditInput.focus();
                locationEditInput.selectionStart = locationEditInput.value.length;
                locationEditInput.selectionEnd = locationEditInput.value.length;
            }, 100);
        }

        // 保存地点批量编辑
        function saveLocationEdit() {
            const editedText = locationEditInput.value.trim();
            if (!editedText) {
                showErrorToast('内容不能为空');
                return;
            }
            
            // 处理连续空格
            const editedItems = editedText.split('\n')
                .filter(item => item.trim())
                .map(item => normalizeSpaces(item.trim()));
            
            if (editedItems.length === 0) {
                showErrorToast('内容不能为空');
                return;
            }
            
            // 检查第一行是否是@开头
            if (!editedItems[0].startsWith('@')) {
                showErrorToast('第一行必须是地点行（以@开头）');
                return;
            }
            
            // 开始事务
            const transaction = db.transaction(['items'], 'readwrite');
            const store = transaction.objectStore('items');
            
            // 先获取所有数据
            const getAllRequest = store.getAll();
            
            getAllRequest.onsuccess = () => {
                const allDBItems = getAllRequest.result;
                const allItems = [];
                
                // 正确处理数据格式
                for (const item of allDBItems) {
                    if (item.value !== undefined) {
                        allItems.push(item.value);
                    } else {
                        console.error('找到异常数据项，没有value字段:', item);
                    }
                }
                
                // 找出当前地点及其资产在数据库中的范围
                let startIndex = currentLocationEditIndex;
                let endIndex = startIndex + 1;
                
                while (endIndex < allItems.length && !allItems[endIndex].startsWith('@')) {
                    endIndex++;
                }
                
                // 计算要删除的项目数
                const deleteCount = endIndex - startIndex;
                
                console.log(`编辑地点位置: ${startIndex} 到 ${endIndex}, 共 ${deleteCount} 项`);
                console.log('编辑前数据:', allItems.slice(startIndex, endIndex));
                console.log('编辑后数据:', editedItems);
                
                // 清除store后重新添加数据
                store.clear().onsuccess = () => {
                    try {
                        let addedCount = 0;
                        let errorCount = 0;
                        
                        // 添加编辑前的数据
                        for (let i = 0; i < startIndex; i++) {
                            try {
                                store.add({ value: allItems[i] });
                                addedCount++;
                            } catch(e) {
                                console.error(`添加编辑前数据出错 [${i}]:`, e);
                                errorCount++;
                            }
                        }
                        
                        // 添加编辑后的数据
                        for (let i = 0; i < editedItems.length; i++) {
                            try {
                                store.add({ value: editedItems[i] });
                                addedCount++;
                            } catch(e) {
                                console.error(`添加编辑后数据出错 [${i}]:`, e);
                                errorCount++;
                            }
                        }
                        
                        // 添加编辑后的剩余数据
                        for (let i = endIndex; i < allItems.length; i++) {
                            try {
                                store.add({ value: allItems[i] });
                                addedCount++;
                            } catch(e) {
                                console.error(`添加剩余数据出错 [${i}]:`, e);
                                errorCount++;
                            }
                        }
                        
                        console.log(`数据处理完成: 成功 ${addedCount} 项, 失败 ${errorCount} 项`);
                        
                        transaction.oncomplete = () => {
                            loadItems();
                            locationEditModal.style.display = 'none';
                            overlay.style.display = 'none';
                            showToast('地点及其资产已更新');
                        };
                        
                        transaction.onerror = (event) => {
                            console.error('保存地点编辑事务出错:', event);
                            showErrorToast('保存失败: ' + (event.target.error?.message || '数据库错误'));
                        };
                    } catch(error) {
                        console.error('批量保存地点编辑出错:', error);
                        showErrorToast('保存失败: ' + error.message);
                    }
                };
            };
        }

        // 添加处理连续空格的函数
        function normalizeSpaces(text) {
            return text.replace(/\s{2,}/g, ' ');
        }

        // 修改搜索函数，排除模板资产
        function searchAssets(keyword) {
            if (!keyword.trim()) {
                searchResults.innerHTML = '<div class="search-count">请输入搜索关键词</div>';
                return;
            }

            let results = [];
            let currentLocation = null;
            let totalCount = 0;
            let firstLocationIndex = -1;
            let isFirstLocation = true;

            items.forEach((item, index) => {
                if (item.startsWith('@')) {
                    currentLocation = item;
                    
                    // 记录第一个地点的索引
                    if (isFirstLocation) {
                        firstLocationIndex = index;
                        isFirstLocation = false;
                    }
                } else if (item.toLowerCase().includes(keyword.toLowerCase())) {
                    // 排除第一个地点（模板资产）下的资产
                    const belongsToFirstLocation = (
                        firstLocationIndex !== -1 && 
                        currentLocation === items[firstLocationIndex]
                    );
                    
                    if (!belongsToFirstLocation) {
                        results.push({
                            location: currentLocation,
                            asset: item
                        });
                        totalCount++;
                    }
                }
            });

            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-count">未找到相关资产</div>';
                return;
            }

            // 按地点分组显示结果
            let html = `<div class="search-count">找到 ${totalCount} 个相关资产</div>`;
            let currentDisplayLocation = null;

            results.forEach(result => {
                if (currentDisplayLocation !== result.location) {
                    if (currentDisplayLocation) {
                        html += '</div>';
                    }
                    currentDisplayLocation = result.location;
                    html += `
                        <div class="search-result-item">
                            <div class="search-result-location">${result.location}</div>
                    `;
                }
                html += `<div class="search-result-asset">${result.asset}</div>`;
            });
            html += '</div>';

            searchResults.innerHTML = html;
        }

        // 修改复制到剪贴板的辅助函数，不复制编号
        function copyToClipboard(text) {
            // 去除文本中的折叠图标符号
            text = text.replace(/[▼▶]/g, '').trim();
            
            // 移除资产编号 (如 "1. ", "2. " 等)
            text = text.replace(/^\d+\.\s+/g, '');
            
            // 创建临时文本区域
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'absolute';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            
            // 选择并复制
            textarea.select();
            document.execCommand('copy');
            
            // 清理
            document.body.removeChild(textarea);
        }

        // 修改显示智能提示函数，从一开始就将建议项倒序显示
        function showSuggestions(text) {
            text = text.trim();
            if (!text) {
                suggestions.style.display = 'none';
                return;
            }

            // 首先将整个列表倒序处理，确保最新添加的项目排在前面
            const reversedItems = [...items].reverse();
            const uniqueItems = [...new Set(reversedItems)];
            
            const filtered = uniqueItems.filter(item => 
                item.toLowerCase().includes(text.toLowerCase())
            );
            
            if (filtered.length === 0) {
                suggestions.style.display = 'none';
                return;
            }

            suggestions.innerHTML = filtered.map(item => 
                `<div class="suggestion-item">${item}</div>`
            ).join('');
            
            suggestions.style.display = 'block';

            // 修改建议项点击事件监听
            const suggestionItems = document.querySelectorAll('.suggestion-item');
            suggestionItems.forEach(item => {
                item.addEventListener('click', () => {
                    itemInput.value = item.textContent;
                    suggestions.style.display = 'none';
                    itemInput.focus(); // 保持输入框焦点
                });
            });
        }

        // 添加点击其他地方关闭智能提示
        document.addEventListener('click', (e) => {
            if (!suggestions.contains(e.target) && e.target !== itemInput) {
                suggestions.style.display = 'none';
            }
        });

        // 输入事件处理
        itemInput.addEventListener('input', (e) => {
            showSuggestions(e.target.value);
        });

        // 添加滚动到底部的函数
        function scrollToBottom() {
            dataList.scrollTop = dataList.scrollHeight;
        }

        // 添加提示函数
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(40, 167, 69, 0.9);
                color: white;
                padding: 10px 20px;
                border-radius: 4px;
                z-index: 1000;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            // 2秒后自动消失
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transition = 'opacity 0.5s';
                setTimeout(() => document.body.removeChild(toast), 500);
            }, 2000);
        }

        // 修改检查@开头行是否重复的函数，使其更严谨
        function checkDuplicateLocation(newItem) {
            if (!newItem.startsWith('@')) {
                return false;
            }
            
            // 获取新输入的地点名称（@后到第一个空格之前的内容）
            const newLocation = newItem.substring(1, newItem.indexOf(' ') > 0 ? newItem.indexOf(' ') : newItem.length);
            
            // 检查现有项目中是否存在相同地点名称
            return items.some(item => {
                if (item.startsWith('@')) {
                    const existingLocation = item.substring(1, item.indexOf(' ') > 0 ? item.indexOf(' ') : item.length);
                    return existingLocation === newLocation;
                }
                return false;
            });
        }

        // 修改添加新项目的函数
        function addNewItem() {
            let newItem = itemInput.value.trim();
            if (newItem) {
                try {
                    // 处理连续空格
                    newItem = normalizeSpaces(newItem);
                    
                    // 检查是否是重复的@开头行
                    if (checkDuplicateLocation(newItem)) {
                        showErrorToast('该地点已存在，请勿重复添加！');
                        return;
                    }
                    
                    console.log('添加新项目:', newItem);
                    saveItem(newItem);
                    itemInput.value = '';
                    suggestions.style.display = 'none';
                    itemInput.focus();
                    
                    // 延迟一点滚动到底部，确保数据加载完成
                    setTimeout(() => {
                        scrollToBottom();
                        showToast('添加成功！');
                    }, 200);
                } catch (error) {
                    console.error('添加新项目时出错:', error);
                    showErrorToast('添加失败，请重试');
                }
            }
        }

        // 修改导出TXT文件的函数
        function exportToTxt() {
            if (items.length === 0) {
                showErrorToast('没有数据可导出！');
                return;
            }

            // 找到第二个@开头的行的索引
            let startIndex = -1;
            let foundFirst = false;
            for (let i = 0; i < items.length; i++) {
                if (items[i].startsWith('@')) {
                    if (!foundFirst) {
                        foundFirst = true;
                    } else {
                        startIndex = i;
                        break;
                    }
                }
            }

            // 如果没有找到第二个@行，说明只有模板数据
            if (startIndex === -1) {
                showErrorToast('没有可导出的数据！');
                return;
            }

            // 只导出从第二个@行开始的数据，并处理连续空格
            const exportItems = items.slice(startIndex).map(item => normalizeSpaces(item));
            const content = exportItems.join('\n');
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = '数据表.txt';
            document.body.appendChild(link);
            link.click();
            
            // 清理
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showToast('导出成功！');
        }

        // 导出TXT功能
        exportButton.addEventListener('click', exportToTxt);

        // 修改显示错误提示的函数
        function showErrorToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(220, 53, 69, 0.9);
                color: white;
                padding: 10px 20px;
                border-radius: 4px;
                z-index: 1000;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transition = 'opacity 0.5s';
                setTimeout(() => document.body.removeChild(toast), 500);
            }, 3000);
        }

        // 优化批量修改函数
        const bulkUpdateItems = (values) => {
            return new Promise((resolve) => {
                const transaction = db.transaction(['items'], 'readwrite');
                const store = transaction.objectStore('items');
                
                // 检查新数据中的地点是否有重复
                const newLocations = new Set();
                const duplicateLocations = [];
                
                // 处理输入值，替换连续空格
                const processedValues = values.map(value => normalizeSpaces(value.trim()));
                
                // 检查新数据中的地点重复
                for (const value of processedValues) {
                    if (value.startsWith('@')) {
                        const location = value.substring(1, value.indexOf(' ') > 0 ? value.indexOf(' ') : value.length);
                        
                        // 检查新数据内部是否有重复
                        if (newLocations.has(location)) {
                            duplicateLocations.push(location);
                            continue;
                        }
                        
                        newLocations.add(location);
                    }
                }
                
                // 如果有重复地点，显示错误信息但不关闭模态框
                if (duplicateLocations.length > 0) {
                    showErrorToast(`发现重复地点: "${duplicateLocations.join('", "')}"，请修正后重试`);
                    resolve(false); // 返回false表示有错误
                    return;
                }
                
                // 显示处理中提示
                showToast('正在处理数据...');
                
                // 没有重复地点，执行修改
            store.clear().onsuccess = () => {
                let addedCount = 0;
                const addItems = processedValues.map(value => {
                    return new Promise((resolve) => {
                        if (value) {
                            const request = store.add({ value: value });
                            request.onsuccess = () => {
                                addedCount++;
                                resolve();
                            };
                            request.onerror = () => {
                                console.error('添加数据失败:', value);
                                resolve();
                            };
                        } else {
                            resolve();
                        }
                    });
                });
                
                Promise.all(addItems).then(() => {
                    transaction.oncomplete = () => {
                        loadItems();
                        showToast(`批量修改成功，共更新${addedCount}条数据！`);
                    };
                });
            };
            return true; // 返回true表示成功
        })
    }

        // 修改批量编辑按钮的点击事件
        batchEditButton.addEventListener('click', () => {
            editAllModal.style.display = 'block';
            overlay.style.display = 'block';
            // 将当前数据填充到文本框中
            editAllInput.value = items.join('\n');
            
            // 将文本框滚动到底部
            setTimeout(() => {
                editAllInput.scrollTop = editAllInput.scrollHeight;
            }, 100);
        });

        // 修改保存批量修改的点击事件
        saveEditAllButton.addEventListener('click', () => {
            const editAllText = editAllInput.value;
            const editAllItems = editAllText.split('\n').filter(item => item.trim());
            
            if (editAllItems.length === 0) {
                showErrorToast('请输入要修改的数据！');
                return;
            }
            
            if (bulkUpdateItems(editAllItems)) {
                editAllModal.style.display = 'none';
                overlay.style.display = 'none';
                editAllInput.value = '';
            }
        });

        // 修改保存编辑的事件处理
        saveEditButton.addEventListener('click', () => {
            let newItem = editInput.value.trim();
            if (newItem) {
                // 处理连续空格
                newItem = normalizeSpaces(newItem);
                updateItem(currentEditIndex, newItem);
                editInput.value = '';
                editModal.style.display = 'none';
                overlay.style.display = 'none';
            }
        });

        // 关闭编辑模态框
        overlay.addEventListener('click', () => {
            editModal.style.display = 'none';
            importModal.style.display = 'none';
            editAllModal.style.display = 'none';
            guideModal.style.display = 'none';
            searchModal.style.display = 'none';
            locationEditModal.style.display = 'none';
            overlay.style.display = 'none';
        });

        // 优化批量添加函数
        const bulkSaveItems = (values) => {
            return new Promise((resolve) => {
                const transaction = db.transaction(['items'], 'readwrite');
                const store = transaction.objectStore('items');
                
                // 先获取所有现有数据来检查地点是否重复
                const getAllRequest = store.getAll();
                
                getAllRequest.onsuccess = () => {
                    const existingItems = getAllRequest.result.map(item => item.value);
                    const existingLocations = new Set();
                    const newLocations = new Set();
                    const duplicateLocations = [];
                    
                    // 处理输入值，替换连续空格
                    const processedValues = values.map(value => normalizeSpaces(value.trim()));
                    
                    // 收集现有的地点
                    existingItems.forEach(item => {
                        if (item.startsWith('@')) {
                            const location = item.substring(1, item.indexOf(' ') > 0 ? item.indexOf(' ') : item.length);
                            existingLocations.add(location);
                        }
                    });
                    
                    // 检查新数据中的地点是否有重复
                    for (const value of processedValues) {
                        if (value.startsWith('@')) {
                            const location = value.substring(1, value.indexOf(' ') > 0 ? value.indexOf(' ') : value.length);
                            
                            // 检查是否与现有地点重复
                            if (existingLocations.has(location)) {
                                duplicateLocations.push(`${location}(已存在)`);
                                continue;
                            }
                            
                            // 检查新数据内部是否有重复
                            if (newLocations.has(location)) {
                                duplicateLocations.push(`${location}(重复)`);
                                continue;
                            }
                            
                            newLocations.add(location);
                        }
                    }
                    
                    // 如果有重复地点，显示错误信息但不关闭模态框
                    if (duplicateLocations.length > 0) {
                        showErrorToast(`发现重复地点: "${duplicateLocations.join('", "')}"，请修正后重试`);
                        resolve(false);
                        return;
                    }
                    
                    // 显示处理中提示
                    showToast('正在导入数据...');
                    
                    // 没有重复地点，执行导入
                    let addedCount = 0;
                    const addItems = processedValues.map(value => {
                        return new Promise((resolve) => {
                if (value) {
                                const request = store.add({ value: value });
                                request.onsuccess = () => {
                                    addedCount++;
                                    resolve();
                                };
                                request.onerror = () => {
                                    console.error('添加数据失败:', value);
                                    resolve();
                                };
                            } else {
                                resolve();
                            }
                        });
                    });
                    
                    Promise.all(addItems).then(() => {
            transaction.oncomplete = () => {
                loadItems();
                            showToast(`批量添加成功，共添加${addedCount}条数据！`);
                            resolve(true);  // 操作成功完成
            };
                    });
                };
            });
        };

        // 批量添加按钮点击事件
        batchAddButton.addEventListener('click', () => {
            importModal.style.display = 'block';
            overlay.style.display = 'block';
            importInput.value = ''; // 清空输入框
        });

        // 确认批量添加按钮点击事件
        savebatchAddButton.addEventListener('click', async () => {  // 添加async
            const importText = importInput.value;
            const importItems = importText.split('\n').filter(item => item.trim());
            
            if (importItems.length === 0) {
                showErrorToast('请输入要导入的数据！');
                return;
            }
            
            const success = await bulkSaveItems(importItems);  // 等待操作完成
            if (success) {
            importModal.style.display = 'none';
            overlay.style.display = 'none';
            importInput.value = '';
            setTimeout(() => {
                scrollToBottom();
            }, 100);
            }
        });

        // 修改 overlay 点击事件，添加关闭所有模态框的逻辑
        overlay.addEventListener('click', () => {
            editModal.style.display = 'none';
            importModal.style.display = 'none';
            editAllModal.style.display = 'none';
            guideModal.style.display = 'none';
            searchModal.style.display = 'none';
            backupModal.style.display = 'none';
            locationEditModal.style.display = 'none';
            overlay.style.display = 'none';
        });

        // 修改删除全部数据的函数
        const deleteAllItems = () => {
            // 找到第二个@开头的行的索引
            let startIndex = -1;
            let foundFirst = false;
            for (let i = 0; i < items.length; i++) {
                if (items[i].startsWith('@')) {
                    if (!foundFirst) {
                        foundFirst = true;
                    } else {
                        startIndex = i;
                        break;
                    }
                }
            }

            // 如果没有找到第二个@行，说明只有模板数据
            if (startIndex === -1) {
                showErrorToast('没有可删除的数据！');
                return;
            }

            const transaction = db.transaction(['items'], 'readwrite');
            const store = transaction.objectStore('items');
            
            // 先获取所有数据
            const getAllRequest = store.getAll();
            
            getAllRequest.onsuccess = () => {
                // 清空所有数据
                store.clear().onsuccess = () => {
                    // 重新添加模板数据（第一个地点及其资产）
                    const templateItems = items.slice(0, startIndex);
                    
                    templateItems.forEach(value => {
                        store.add({ value });
                    });
                    
                    transaction.oncomplete = () => {
                loadItems();
                        showToast('删除成功！');
                    };
                };
            };
        };

        // 修改删除全部按钮的点击事件
        deleteAllButton.addEventListener('click', () => {
            // 找到第二个@开头的行的索引
            let startIndex = -1;
            let foundFirst = false;
            for (let i = 0; i < items.length; i++) {
                if (items[i].startsWith('@')) {
                    if (!foundFirst) {
                        foundFirst = true;
                    } else {
                        startIndex = i;
                        break;
                    }
                }
            }
            
            if (startIndex === -1) {
                showErrorToast('没有可删除的数据！');
                return;
            }
            
            if (confirm('确定要删除所有数据吗？（模板资产将保留）此操作不可恢复！')) {
                deleteAllItems();
            }
        });

        // 添加关闭指南按钮事件
        closeGuideButton.addEventListener('click', () => {
            guideModal.style.display = 'none';
            overlay.style.display = 'none';
        });

        // 添加键盘事件监听，支持 ESC 键关闭模态框
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                editModal.style.display = 'none';
                importModal.style.display = 'none';
                editAllModal.style.display = 'none';
                guideModal.style.display = 'none';
                searchModal.style.display = 'none';
                locationEditModal.style.display = 'none';
                overlay.style.display = 'none';
            }
        });

        // 添加一键折叠/展开函数
        function toggleAllLocations() {
            try {
                const locationItems = document.querySelectorAll('.location-item');
                if (locationItems.length === 0) {
                    console.log('未找到地点行，无法执行折叠/展开操作');
                    return;
                }
                
                isAllCollapsed = !isAllCollapsed;
                console.log(`执行${isAllCollapsed ? '折叠' : '展开'}所有地点操作`);
                
                locationItems.forEach(item => {
                    // 跳过第一个地点（模板资产）
                    if (item.getAttribute('data-location-index') === '0') {
                        return;
                    }
                    
                    const locationIndex = item.getAttribute('data-location-index');
                    const assets = document.querySelectorAll(`[data-belongs-to="${locationIndex}"]`);
                    const collapseIcon = item.querySelector('.collapse-icon');
                    
                    if (assets.length > 0) {
                        assets.forEach(asset => {
                            asset.style.display = isAllCollapsed ? 'none' : 'flex';
                        });
                        collapseIcon.textContent = isAllCollapsed ? '▶' : '▼';
                    }
                });
                
                // 更新按钮图标
                collapseAllButton.textContent = isAllCollapsed ? '▶' : '▼';
            } catch (error) {
                console.error('折叠/展开所有地点时出错:', error);
            }
        }

        // 添加按钮点击事件
        collapseAllButton.addEventListener('click', toggleAllLocations);

        // 注释掉这里的初始化，仅在DOMContentLoaded事件中初始化一次
        // initDB();
        // refreshList();
        
        // 添加定期内存清理
        setInterval(() => {
            if (appSettings.autoReleaseMemory && items.length > 500) {
                console.log('执行定期内存清理...');
                nodeCache = {}; // 清空节点缓存
                
                // 尝试触发垃圾回收
                if (perfMonitor.enabled && perfMonitor.memoryUsage.length > 0) {
                    const latestMemory = perfMonitor.memoryUsage[perfMonitor.memoryUsage.length - 1];
                    if (latestMemory.used > 200) { // 如果内存使用超过200MB
                        perfMonitor.releaseResources();
                    }
                }
            }
        }, 60000); // 每分钟执行一次

        // 修改键盘事件支持
        itemInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const newItem = itemInput.value.trim();
                if (newItem) {
                    addNewItem();
                }
            }
        });

        editInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                saveEditButton.click();
            }
        });

        // 添加保存按钮事件监听
        saveLocationEditButton.addEventListener('click', saveLocationEdit);

        // 添加搜索按钮点击事件
        searchButton.addEventListener('click', () => {
            searchModal.style.display = 'block';
            overlay.style.display = 'block';
            searchInput.value = '';
            searchInput.focus();
            searchResults.innerHTML = '<div class="search-count">请输入搜索关键词</div>';
        });

        // 添加搜索输入框事件（实时搜索）
        searchInput.addEventListener('input', (e) => {
            searchAssets(e.target.value);
        });

        // 添加关闭搜索按钮事件
        closeSearchButton.addEventListener('click', () => {
            searchModal.style.display = 'none';
            overlay.style.display = 'none';
        });

        // 添加性能监控功能
        let perfMonitor = {
            lastRefreshTime: 0,
            frameCount: 0,
            memoryUsage: [],
            enabled: false,
            
            // 初始化性能监控
            init() {
                this.lastRefreshTime = performance.now();
                this.frameCount = 0;
                this.memoryUsage = [];
                this.enabled = false;
            },
            
            // 记录性能数据
            record() {
                if (!this.enabled) return;
                
                this.frameCount++;
                const currentTime = performance.now();
                
                // 每秒记录一次
                if (currentTime - this.lastRefreshTime >= 1000) {
                    const fps = Math.round(this.frameCount * 1000 / (currentTime - this.lastRefreshTime));
                    console.log(`性能监控: FPS = ${fps}`);
                    
                    // 记录内存使用情况(如果浏览器支持)
                    if (window.performance && window.performance.memory) {
                        const memory = window.performance.memory;
                        const memoryUsed = Math.round(memory.usedJSHeapSize / (1024 * 1024));
                        const memoryTotal = Math.round(memory.totalJSHeapSize / (1024 * 1024));
                        console.log(`内存使用: ${memoryUsed}MB / ${memoryTotal}MB`);
                        
                        this.memoryUsage.push({
                            time: new Date(),
                            used: memoryUsed,
                            total: memoryTotal
                        });
                        
                        // 只保留最近10次记录
                        if (this.memoryUsage.length > 10) {
                            this.memoryUsage.shift();
                        }
                    }
                    
                    this.frameCount = 0;
                    this.lastRefreshTime = currentTime;
                    
                    // 如果内存占用过高，尝试回收一些资源
                    this.checkMemory();
                }
                
                // 请求下一帧记录
                requestAnimationFrame(() => this.record());
            },
            
            // 检查内存占用并尝试释放
            checkMemory() {
                if (this.memoryUsage.length < 2) return;
                
                const latest = this.memoryUsage[this.memoryUsage.length - 1];
                const previous = this.memoryUsage[this.memoryUsage.length - 2];
                
                // 如果内存增长超过20%，尝试释放一些资源
                if (latest.used > previous.used * 1.2 && latest.used > 200) {
                    console.log('检测到内存使用量大幅增加，尝试优化...');
                    this.releaseResources();
                }
            },
            
            // 释放一些不必要的资源
            releaseResources() {
                // 清除一些不必要的DOM引用
                nodeCache = {};
                
                // 释放闲置的事件监听器
                if (dataList.children.length > 500) {
                    setupEventDelegation();
                }
                
                // 强制垃圾回收(虽然不能直接调用，但可以尝试释放一些变量)
                const largeArray = [];
                // 创建大型对象然后立即释放，可能触发GC
                for (let i = 0; i < 10000; i++) {
                    largeArray.push(new Array(10000).fill(0));
                }
                largeArray.length = 0;
            },
            
            // 启用性能监控
            enable() {
                this.enabled = true;
                this.record();
                console.log('性能监控已启用');
            },
            
            // 停用性能监控
            disable() {
                this.enabled = false;
                console.log('性能监控已停用');
            }
        };
        
        // 缓存DOM节点引用
        let nodeCache = {};
        
        // 获取DOM节点的辅助函数(带缓存)
        function getNode(selector) {
            if (!nodeCache[selector]) {
                nodeCache[selector] = document.querySelector(selector);
            }
            return nodeCache[selector];
        }
        
        // 针对大型数据的优化设置
        let appSettings = {
            usePagination: false,      // 是否使用分页而不是无限滚动
            pageSize: 200,             // 每页显示的项目数量
            currentPage: 1,            // 当前页码
            batchSize: 100,            // 批处理大小
            lazyLoadImages: true,      // 是否延迟加载图片(如果有)
            autoReleaseMemory: true,   // 是否自动释放内存
            
            // 根据数据规模自动调整设置
            adjustForDataSize() {
                if (items.length > 1000) {
                    this.usePagination = true;
                    this.pageSize = 200;
                    this.batchSize = 100;
                    perfMonitor.enable(); // 启用性能监控
                } else if (items.length > 500) {
                    this.usePagination = false;
                    this.batchSize = 100;
                    perfMonitor.disable(); // 停用性能监控
                } else {
                    this.usePagination = false;
                    this.batchSize = items.length;
                    perfMonitor.disable(); // 停用性能监控
                }
            }
        };
        
        // 初始化时执行
        perfMonitor.init();
        
        // 添加回到底部按钮
        addScrollBottomButton();

        // 在页面加载完成后执行的初始化函数
        window.addEventListener('DOMContentLoaded', () => {
            console.log('页面加载完成，初始化应用');
            
            // 初始化数据库
            initDB();
            
            // 添加输入框事件监听
            itemInput.addEventListener('input', (e) => {
                showSuggestions(e.target.value);
            });
            
            // 添加键盘事件
            itemInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const newItem = itemInput.value.trim();
                    if (newItem) {
                        addNewItem();
                    }
                }
            });
            
            // 其他按钮初始化
            exportButton.addEventListener('click', exportToTxt);
            batchAddButton.addEventListener('click', () => {
                importModal.style.display = 'block';
                overlay.style.display = 'block';
                importInput.value = ''; // 清空输入框
            });
        });

        // 添加检查数据显示的函数，修复可能的问题
        function checkAndRepairDisplay() {
            console.log('检查数据显示状态...');
            
            // 如果列表为空但有数据，重新渲染
            if (dataList.children.length === 0 && items.length > 0) {
                console.log('检测到数据未显示，重新渲染');
                renderSimpleList();
                return true;
            }
            
            // 检查折叠状态是否一致
            const locationItems = document.querySelectorAll('.location-item');
            locationItems.forEach(item => {
                const locationIndex = item.getAttribute('data-location-index');
                const assets = document.querySelectorAll(`[data-belongs-to="${locationIndex}"]`);
                const collapseIcon = item.querySelector('.collapse-icon');
                
                if (assets.length > 0) {
                    const isHidden = assets[0].style.display === 'none';
                    collapseIcon.textContent = isHidden ? '▶' : '▼';
                }
            });
            
            return false;
        }

        // 修改显示错误提示的函数
        function showErrorToast(message) {
            console.error('错误:', message);
            
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(220, 53, 69, 0.9);
                color: white;
                padding: 10px 20px;
                border-radius: 4px;
                z-index: 1000;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transition = 'opacity 0.5s';
                setTimeout(() => document.body.removeChild(toast), 500);
            }, 3000);
            
            // 检查数据显示
            setTimeout(checkAndRepairDisplay, 1000);
        }

        // 添加自动备份功能
        function setupBackup() {
            // 加载备份设置
            loadBackupSettings();
            
            // 加载已有备份列表
            loadBackups();
            
            // 设置自动备份定时器
            setupBackupTimer();
            
            // 添加备份按钮到页面
            addBackupButton();
            
            // 添加事件监听
            manualBackupButton.addEventListener('click', () => createBackup(false));
            restoreBackupButton.addEventListener('click', promptRestoreBackup);
            exportBackupButton.addEventListener('click', exportBackup);
            importBackupButton.addEventListener('click', () => backupFileInput.click());
            backupFileInput.addEventListener('change', importBackup);
            closeBackupModalButton.addEventListener('click', () => {
                backupModal.style.display = 'none';
                overlay.style.display = 'none';
            });
            
            // 设置变更监听
            autoBackupEnabledCheckbox.addEventListener('change', updateBackupSettings);
            backupFrequencySelect.addEventListener('change', updateBackupSettings);
            backupRetentionSelect.addEventListener('change', updateBackupSettings);
            
            console.log('备份系统已初始化');
        }
        
        // 添加回到底部按钮到界面
        function addScrollBottomButton() {
            const scrollBottomButton = document.createElement('button');
            scrollBottomButton.id = 'scrollBottomButton';
            scrollBottomButton.title = '回到列表底部';
            scrollBottomButton.textContent = '↓';
            
            scrollBottomButton.addEventListener('mouseover', () => {
                scrollBottomButton.style.backgroundColor = 'rgba(40, 167, 69, 1)';
                scrollBottomButton.style.transform = 'translateY(-2px)';
                scrollBottomButton.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
            });
            
            scrollBottomButton.addEventListener('mouseout', () => {
                scrollBottomButton.style.backgroundColor = 'rgba(40, 167, 69, 0.8)';
                scrollBottomButton.style.transform = '';
                scrollBottomButton.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            });
            
            scrollBottomButton.addEventListener('click', () => {
                scrollToBottom();
                showToast('已滚动到底部');
            });
            
            document.body.appendChild(scrollBottomButton);
        }
        
        // 添加备份按钮到界面
        function addBackupButton() {
            const backupButton = document.createElement('button');
            backupButton.id = 'backupButton';
            backupButton.title = '数据备份与恢复';
            backupButton.textContent = '💾';
            backupButton.style.cssText = `
                position: fixed;
                left: 20px;
                bottom: 20px;
                width: 40px;
                height: 40px;
                background-color: rgba(0, 123, 255, 0.8);
                color: white;
                border: none;
                border-radius: 50%;
                cursor: pointer;
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 20px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                transition: all 0.3s ease;
                z-index: 999;
            `;
            
            backupButton.addEventListener('mouseover', () => {
                backupButton.style.backgroundColor = 'rgba(0, 123, 255, 1)';
                backupButton.style.transform = 'translateY(-2px)';
                backupButton.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
            });
            
            backupButton.addEventListener('mouseout', () => {
                backupButton.style.backgroundColor = 'rgba(0, 123, 255, 0.8)';
                backupButton.style.transform = '';
                backupButton.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            });
            
            backupButton.addEventListener('click', openBackupModal);
            
            document.body.appendChild(backupButton);
        }
        
        // 打开备份模态框
        function openBackupModal() {
            updateBackupsList();
            updateBackupUI();
            
            backupModal.style.display = 'block';
            overlay.style.display = 'block';
        }
        
        // 更新备份设置UI
        function updateBackupUI() {
            lastBackupTimeSpan.textContent = backupSettings.lastBackupTime 
                ? new Date(backupSettings.lastBackupTime).toLocaleString() 
                : '无';
                
            backupStatusSpan.textContent = backupSettings.enabled ? '已启用' : '已禁用';
            autoBackupEnabledCheckbox.checked = backupSettings.enabled;
            backupFrequencySelect.value = backupSettings.frequency.toString();
            backupRetentionSelect.value = backupSettings.retention.toString();
        }
        
        // 加载备份设置
        function loadBackupSettings() {
            try {
                const savedSettings = localStorage.getItem('backupSettings');
                if (savedSettings) {
                    backupSettings = JSON.parse(savedSettings);
                    console.log('已加载备份设置:', backupSettings);
                }
            } catch (error) {
                console.error('加载备份设置出错:', error);
                // 使用默认设置
                backupSettings = {
                    enabled: true,
                    frequency: 86400000,
                    retention: 3,
                    lastBackupTime: null
                };
            }
        }
        
        // 保存备份设置
        function saveBackupSettings() {
            try {
                localStorage.setItem('backupSettings', JSON.stringify(backupSettings));
                console.log('备份设置已保存');
            } catch (error) {
                console.error('保存备份设置出错:', error);
                showErrorToast('保存备份设置失败');
            }
        }
        
        // 更新备份设置
        function updateBackupSettings() {
            backupSettings.enabled = autoBackupEnabledCheckbox.checked;
            backupSettings.frequency = parseInt(backupFrequencySelect.value);
            backupSettings.retention = parseInt(backupRetentionSelect.value);
            
            saveBackupSettings();
            setupBackupTimer(); // 重新设置定时器
            updateBackupUI(); // 更新界面
            
            showToast('备份设置已更新');
        }
        
        // 设置备份定时器
        function setupBackupTimer() {
            // 清除现有定时器
            if (backupTimer) {
                clearInterval(backupTimer);
                backupTimer = null;
            }
            
            // 如果启用了自动备份
            if (backupSettings.enabled) {
                backupTimer = setInterval(() => {
                    console.log('执行自动备份...');
                    createBackup(true);
                }, backupSettings.frequency);
                
                console.log(`自动备份已设置，频率: ${backupSettings.frequency / (1000 * 60 * 60)} 小时`);
            } else {
                console.log('自动备份已禁用');
            }
        }
        
        // 创建备份
        function createBackup(isAuto = false) {
            try {
                if (!db) {
                    showErrorToast('数据库未准备好，无法备份');
                    return;
                }
                
                const transaction = db.transaction(['items'], 'readonly');
                const store = transaction.objectStore('items');
                const request = store.getAll();
                
                request.onsuccess = () => {
                    const currentData = request.result;
                    
                    if (!currentData || currentData.length === 0) {
                        showErrorToast('没有数据可备份');
                        return;
                    }
                    
                    // 创建备份对象
                    const timestamp = new Date().getTime();
                    const backupName = `backup_${timestamp}`;
                    const backup = {
                        id: backupName,
                        timestamp: timestamp,
                        description: isAuto ? '自动备份' : '手动备份',
                        data: currentData,
                        itemCount: currentData.length
                    };
                    
                    // 保存备份到localStorage
                    try {
                        localStorage.setItem(backupName, JSON.stringify(backup));
                        
                        // 更新备份列表
                        loadBackups();
                        
                        // 更新最后备份时间
                        backupSettings.lastBackupTime = timestamp;
                        saveBackupSettings();
                        
                        // 管理备份数量
                        manageBackups();
                        
                        console.log(`备份创建成功: ${backupName}, 包含 ${currentData.length} 条记录`);
                        
                        if (!isAuto) {
                            showToast('备份创建成功！');
                            updateBackupUI();
                            updateBackupsList();
                        }
                    } catch (error) {
                        console.error('保存备份到localStorage出错:', error);
                        
                        // 如果localStorage空间不足，尝试导出到文件
                        if (error.name === 'QuotaExceededError') {
                            showErrorToast('存储空间不足，尝试导出到文件');
                            exportBackupToFile(backup);
                        } else {
                            showErrorToast('创建备份失败: ' + error.message);
                        }
                    }
                };
                
                request.onerror = (event) => {
                    console.error('获取备份数据出错:', event.target.error);
                    showErrorToast('获取备份数据失败');
                };
            } catch (error) {
                console.error('创建备份时出错:', error);
                showErrorToast('创建备份失败');
            }
        }
        
        // 导出备份到文件
        function exportBackupToFile(backup) {
            try {
                const backupBlob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(backupBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `快速库存清单_备份_${new Date(backup.timestamp).toLocaleString().replace(/[\/\s:]/g, '_')}.json`;
                document.body.appendChild(link);
                link.click();
                
                // 清理
                setTimeout(() => {
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                }, 100);
                
                showToast('备份已导出到文件');
            } catch (error) {
                console.error('导出备份到文件出错:', error);
                showErrorToast('导出备份失败: ' + error.message);
            }
        }
        
        // 管理备份数量
        function manageBackups() {
            try {
                // 按时间降序排列备份
                backups.sort((a, b) => b.timestamp - a.timestamp);
                
                // 如果超过保留数量，删除旧备份
                if (backups.length > backupSettings.retention) {
                    console.log(`备份数量(${backups.length})超过保留限制(${backupSettings.retention})，删除旧备份`);
                    
                    const backupsToRemove = backups.slice(backupSettings.retention);
                    backupsToRemove.forEach(backup => {
                        try {
                            localStorage.removeItem(backup.id);
                            console.log(`已删除旧备份: ${backup.id}`);
                        } catch (error) {
                            console.error(`删除备份 ${backup.id} 出错:`, error);
                        }
                    });
                    
                    // 更新备份列表
                    loadBackups();
                }
            } catch (error) {
                console.error('管理备份数量出错:', error);
            }
        }
        
        // 加载所有备份
        function loadBackups() {
            try {
                backups = [];
                
                // 查找localStorage中的所有备份
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    
                    if (key.startsWith('backup_')) {
                        try {
                            const backup = JSON.parse(localStorage.getItem(key));
                            backups.push(backup);
                        } catch (error) {
                            console.error(`解析备份 ${key} 出错:`, error);
                        }
                    }
                }
                
                // 按时间降序排列
                backups.sort((a, b) => b.timestamp - a.timestamp);
                console.log(`已加载 ${backups.length} 个备份`);
                
                return backups;
            } catch (error) {
                console.error('加载备份列表出错:', error);
                return [];
            }
        }
        
        // 更新备份列表UI
        function updateBackupsList() {
            try {
                backupsList.innerHTML = '';
                
                if (backups.length === 0) {
                    backupsList.innerHTML = '<div class="no-backup">暂无备份</div>';
                    return;
                }
                
                // 创建备份列表
                backups.forEach(backup => {
                    const backupItem = document.createElement('div');
                    backupItem.className = 'backup-item';
                    
                    const dateStr = new Date(backup.timestamp).toLocaleString();
                    const itemCount = backup.itemCount || '未知';
                    
                    backupItem.innerHTML = `
                        <div class="backup-item-info">
                            <div class="backup-item-time">${dateStr}</div>
                            <div class="backup-item-desc">${backup.description}</div>
                            <div class="backup-item-count">项目数: ${itemCount}</div>
                        </div>
                        <div class="backup-item-actions">
                            <button class="backup-restore-btn" data-id="${backup.id}">恢复</button>
                            <button class="backup-export-btn" data-id="${backup.id}">导出</button>
                            <button class="backup-delete-btn" data-id="${backup.id}">删除</button>
                        </div>
                    `;
                    
                    backupsList.appendChild(backupItem);
                });
                
                // 添加备份操作事件
                document.querySelectorAll('.backup-restore-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const backupId = e.target.getAttribute('data-id');
                        restoreBackup(backupId);
                    });
                });
                
                document.querySelectorAll('.backup-export-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const backupId = e.target.getAttribute('data-id');
                        const backup = backups.find(b => b.id === backupId);
                        if (backup) {
                            exportBackupToFile(backup);
                        }
                    });
                });
                
                document.querySelectorAll('.backup-delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const backupId = e.target.getAttribute('data-id');
                        if (confirm('确定要删除此备份吗？')) {
                            deleteBackup(backupId);
                        }
                    });
                });
            } catch (error) {
                console.error('更新备份列表UI出错:', error);
                backupsList.innerHTML = '<div class="backup-error">加载备份列表出错</div>';
            }
        }
        
        // 提示恢复备份
        function promptRestoreBackup() {
            if (backups.length === 0) {
                showErrorToast('没有可用的备份');
                return;
            }
            
            if (confirm('确定要恢复备份吗？当前数据将被替换。')) {
                // 默认恢复最新的备份
                restoreBackup(backups[0].id);
            }
        }
        
        // 恢复备份
        function restoreBackup(backupId) {
            try {
                const backupJson = localStorage.getItem(backupId);
                
                if (!backupJson) {
                    showErrorToast('找不到指定的备份');
                    return;
                }
                
                const backup = JSON.parse(backupJson);
                
                if (!backup.data || backup.data.length === 0) {
                    showErrorToast('备份数据为空或无效');
                    return;
                }
                
                // 确认对话框 - 先确认，再显示处理中提示
                if (!confirm(`确定要从"${new Date(backup.timestamp).toLocaleString()}"的备份恢复${backup.data.length}条数据吗？当前数据将被替换。`)) {
                    return;
                }
                
                // 显示处理中提示
                showToast('正在恢复数据...');
                
                // 使用setTimeout给UI更新的时间
                setTimeout(() => {
                    try {
                        // 清空当前数据并恢复备份
                        const transaction = db.transaction(['items'], 'readwrite');
                        const store = transaction.objectStore('items');
                        
                        // 添加错误处理
                        transaction.onerror = (event) => {
                            console.error('恢复备份事务错误:', event.target.error);
                            showErrorToast('恢复过程中发生错误：' + event.target.error.message);
                        };
                        
                        // 清除现有数据
                        const clearRequest = store.clear();
                        
                        clearRequest.onerror = (event) => {
                            console.error('清除数据错误:', event.target.error);
                            showErrorToast('清除现有数据失败：' + event.target.error.message);
                            return;
                        };
                        
                        clearRequest.onsuccess = () => {
                            let addedCount = 0;
                            let errorCount = 0;
                            const batchSize = 50; // 增大批次大小提高性能
                            
                            // 分批添加数据 - 改用迭代方式而非递归，避免调用栈溢出
                            function processBatch(startIndex) {
                                let endIndex = Math.min(startIndex + batchSize, backup.data.length);
                                console.log(`处理备份数据批次 ${startIndex} - ${endIndex}`);
                                
                                for (let i = startIndex; i < endIndex; i++) {
                                    const item = backup.data[i];
                                    try {
                                        const request = store.add(item);
                                        request.onsuccess = () => { addedCount++; };
                                        request.onerror = (event) => {
                                            console.error(`添加数据项 ${i} 失败:`, event.target.error);
                                            errorCount++;
                                        };
                                    } catch (err) {
                                        console.error(`处理数据项 ${i} 出错:`, err);
                                        errorCount++;
                                    }
                                }
                                
                                // 处理下一批数据
                                if (endIndex < backup.data.length) {
                                    // 使用setTimeout让浏览器有时间更新UI
                                    setTimeout(() => processBatch(endIndex), 10);
                                }
                            }
                            
                            // 开始处理第一批
                            processBatch(0);
                            
                            transaction.oncomplete = () => {
                                console.log(`备份恢复完成: 添加 ${addedCount} 项，失败 ${errorCount} 项`);
                                
                                // 关闭备份模态框
                                backupModal.style.display = 'none';
                                overlay.style.display = 'none';
                                
                                // 重新加载数据
                                loadItems();
                                showToast(`备份恢复成功，共恢复 ${addedCount} 条数据！`);
                            };
                        };
                    } catch (innerError) {
                        console.error('恢复过程中发生错误:', innerError);
                        showErrorToast('恢复失败: ' + innerError.message);
                    }
                }, 100); // 给UI时间显示处理中的提示
                
            } catch (error) {
                console.error('恢复备份出错:', error);
                showErrorToast('恢复备份失败: ' + error.message);
            }
        }
        
        // 删除备份
        function deleteBackup(backupId) {
            try {
                localStorage.removeItem(backupId);
                console.log(`备份 ${backupId} 已删除`);
                
                // 更新备份列表
                loadBackups();
                updateBackupsList();
                showToast('备份已删除');
            } catch (error) {
                console.error('删除备份出错:', error);
                showErrorToast('删除备份失败: ' + error.message);
            }
        }
        
        // 导出当前备份
        function exportBackup() {
            // 先创建一个备份，然后导出
            try {
                const transaction = db.transaction(['items'], 'readonly');
                const store = transaction.objectStore('items');
                const request = store.getAll();
                
                request.onsuccess = () => {
                    const currentData = request.result;
                    
                    if (!currentData || currentData.length === 0) {
                        showErrorToast('没有数据可导出');
                        return;
                    }
                    
                    // 创建备份对象
                    const timestamp = new Date().getTime();
                    const backup = {
                        id: `export_${timestamp}`,
                        timestamp: timestamp,
                        description: '手动导出',
                        data: currentData,
                        itemCount: currentData.length
                    };
                    
                    exportBackupToFile(backup);
                };
            } catch (error) {
                console.error('导出备份出错:', error);
                showErrorToast('导出备份失败: ' + error.message);
            }
        }
        
        // 导入备份
        function importBackup(e) {
            try {
                const file = e.target.files[0];
                if (!file) {
                    return;
                }
                
                const reader = new FileReader();
                
                reader.onload = (event) => {
                    try {
                        const backup = JSON.parse(event.target.result);
                        
                        if (!backup.data || !backup.timestamp) {
                            showErrorToast('备份文件格式无效');
                            return;
                        }
                        
                        // 导入备份到localStorage
                        const backupId = `backup_${new Date().getTime()}`; // 使用新的ID避免冲突
                        backup.id = backupId;
                        backup.description = '从文件导入';
                        
                        localStorage.setItem(backupId, JSON.stringify(backup));
                        
                        // 更新备份列表
                        loadBackups();
                        updateBackupsList();
                        showToast('备份已导入');
                    } catch (error) {
                        console.error('解析备份文件出错:', error);
                        showErrorToast('备份文件格式错误');
                    }
                };
                
                reader.onerror = () => {
                    showErrorToast('读取备份文件失败');
                };
                
                reader.readAsText(file);
                
                // 清空文件输入框，允许选择同一文件
                e.target.value = '';
            } catch (error) {
                console.error('导入备份出错:', error);
                showErrorToast('导入备份失败: ' + error.message);
            }
        }
    </script>
</body>
</html>
